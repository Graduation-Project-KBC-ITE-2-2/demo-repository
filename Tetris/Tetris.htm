<!DOCTYPE html>
<html>
<head>
    <title>テトリス</title>
    <meta charset="utf-8" />
    <style>
        /* CSSスタイル */
        body {
            margin: 0; /* ページ全体の外側の余白をなくします。*/
            padding: 0; /*ページ内の余白もなくします。*/
            height: 100vh; /* ビューポートの高さを100%に設定しています。
             vhはビューポートの高さの単位で、100vhは画面の高さ全体を意味します。 */
            display: flex; /* フレックスボックスを使って要素を配置します。
             フレックスボックスは要素の配置や中央揃えが簡単に行えるレイアウト方法です。*/
            justify-content: center; /* フレックスボックスの要素を水平方向に中央揃えします。 */
            align-items: center;     /* フレックスボックスの要素を垂直方向に中央揃えします。 */
            overflow: hidden; /* ぺージのスクロールバーが表示されないようにします。 */
        }

        #canvas {
            border: 1px solid black; /* キキャンバス要素に黒の1ピクセル幅の枠線をつけます。 */
            display: block; /*canvas要素をブロック要素にします。
             これはデフォルトのインライン要素をブロックに変更し、他の要素と分かれて表示されるようにします。*/
            margin: 0 auto; /* キキャンバスを左右の中央に配置します。
             autoは、左右の余白を自動調整して中央揃えにする効果があります。 */
        }

        /* モーダルウィンドウのスタイル */
         /* モーダルウィンドウとは、ユーザーの操作を一時的に中断し、
          特定のアクションを促すために表示されるポップアップウィンドウの一種です。 */
        .modal {
            position: fixed; /* モーダルウィンドウがスクロールしても常に画面の同じ位置に固定されます。 */
            z-index: 1; /* 他の要素の上にモーダルが表示されるように、スタッキング順序を設定します
             （z-indexが高いほど前面に表示されます）。 */
            left: 0; /* モーダルウィンドウの位置を画面の左上に固定します。 */
            top: 0; /* モーダルウィンドウの位置を画面の左上に固定します。 */
            width: 100%; /* モーダルが画面全体を覆うようにします。 */
            height: 100%; /* モーダルが画面全体を覆うようにします。 */
            overflow: auto; /* モーダル内で内容が画面に収まりきらない場合にスクロール可能にします。 */
            background-color: rgba(0,0,0,0.5); /* 背景を半透明の黒で覆い、画面全体に暗い効果を与えます。 */
        }

        .modal-content {
            background-color: #fefefe; /* モーダルの背景色を白（薄いグレー）に設定します。 */
            margin: 15% auto; /* 上モーダルウィンドウを上下で15%中央寄せ、左右は自動で中央揃えにします。 */
            padding: 20px; /* モーダルの内部に20ピクセルの余白を追加します。 */
            border: 1px solid #888; /* モーダルに薄いグレーの1ピクセル幅の枠線をつけます。 */
            width: 300px; /* モーダルの幅を300ピクセルに固定します。 */
            text-align: center; /* 上モーダル内のテキストを中央揃えにします。 */
        }

        /* ボタンのスタイル */
        #retryButton, #returnButton {
            margin: 10px; /* ボタンの外側に10ピクセルの余白を追加します。 */
            padding: 10px 20px; /* ボタン内のテキスト周りに、上下10ピクセル、左右20ピクセルの余白を追加します。
            */
            font-size: 16px; /* ボタン内の文字サイズを16ピクセルに設定します。 */
            cursor: pointer; /* ボタンにマウスを乗せるとポインター（手の形）が表示されます。 */
        }
    </style>
    <script type="text/javascript">
    "use strict";
    var ctx, W = 12, H = 22, field, block, nextBlock, keyevents = [];
    var interval = 40, count, score, timer;

    var colors = ['black', 'orange', 'blue', 'aqua',
        'lime', 'fuchsia', 'yellow', 'red', 'gray'];

    var blocks = [
        [
            [
                0, 0, 1,
                1, 1, 1,
                0, 0, 0
            ], [
                0, 1, 0,
                0, 1, 0,
                0, 1, 1
            ], [
                0, 0, 0,
                1, 1, 1,
                1, 0, 0
            ], [
                1, 1, 0,
                0, 1, 0,
                0, 1, 0
            ],
        ], [
            [
                2, 0, 0,
                2, 2, 2,
                0, 0, 0
            ], [
                0, 2, 2,
                0, 2, 0,
                0, 2, 0
            ], [
                0, 0, 0,
                2, 2, 2,
                0, 0, 2
            ], [
                0, 2, 0,
                0, 2, 0,
                2, 2, 0
            ]
        ], [
            [
                0, 3, 0,
                3, 3, 3,
                0, 0, 0
            ], [
                0, 3, 0,
                0, 3, 3,
                0, 3, 0
            ], [
                0, 0, 0,
                3, 3, 3,
                0, 3, 0
            ], [
                0, 3, 0,
                3, 3, 0,
                0, 3, 0
            ]
        ], [
            [
                4, 4, 0,
                0, 4, 4,
                0, 0, 0
            ], [
                0, 0, 4,
                0, 4, 4,
                0, 4, 0
            ], [
                0, 0, 0,
                4, 4, 0,
                0, 4, 4
            ], [
                0, 4, 0,
                4, 4, 0,
                4, 0, 0
            ]
        ], [
            [
                0, 5, 5,
                5, 5, 0,
                0, 0, 0
            ], [
                0, 5, 0,
                0, 5, 5,
                0, 0, 5
            ], [
                0, 0, 0,
                0, 5, 5,
                5, 5, 0
            ], [
                5, 0, 0,
                5, 5, 0,
                0, 5, 0
            ]
        ], [
            [
                6, 6,
                6, 6
            ], [
                6, 6,
                6, 6
            ], [
                6, 6,
                6, 6
            ], [
                6, 6,
                6, 6
            ]
        ], [
            [
                0, 7, 0, 0,
                0, 7, 0, 0,
                0, 7, 0, 0,
                0, 7, 0, 0
            ], [
                0, 0, 0, 0,
                7, 7, 7, 7,
                0, 0, 0, 0,
                0, 0, 0, 0
            ], [
                0, 0, 7, 0,
                0, 0, 7, 0,
                0, 0, 7, 0,
                0, 0, 7, 0
            ], [
                0, 0, 0, 0,
                0, 0, 0, 0,
                7, 7, 7, 7,
                0, 0, 0, 0
            ]
        ]
    ];

    function Block() {
        this.turn = rand(4);                    // 向き
        this.type = blocks[rand(blocks.length)];
        this.data = this.type[this.turn];

        this.w = Math.sqrt(this.data.length);   // 2 or 3 or 4
        this.x = rand(6 - this.w) + 2;          // 落下開始時のx座標
        this.y = 1 - this.w;
        this.fire = interval + count;

        this.update = function () {
            // 一番下に到達？
            if (isHit(this.x, this.y + 1, this.turn)) {
                processBlockCells(function (x, y, value) {
                    field[y][x] = value;
                });

                var erased = eraseLine();
                if (erased > 0) {
                    score += Math.pow(2, erased) * 10;
                }

                keyevents = [];
                goNextBlock();
            }

            // ブロックを1行下へ移動
            if (this.fire < count) {
                this.fire = count + interval;
                this.y++;
            }

            // キーイベントの処理
            while (keyevents.length > 0) {
                var code = keyevents.shift();
                var dx = 0, dy = 0, nd = this.turn;

                switch (code) {
                    case 32: nd = (nd + 1) % 4; break;
                    case 37: dx = -1; break;
                    case 39: dx = +1; break;
                    case 40: dy = +1; break;
                    default: continue;
                }

                if (!isHit(this.x + dx, this.y + dy, nd)) {
                    this.x = this.x + dx;
                    this.y = this.y + dy;
                    this.turn = nd;
                    this.data = this.type[this.turn];
                }
            }
        };

        this.draw = function (ctx) {
            processBlockCells(function (x, y, value) {
                ctx.fillStyle = colors[value];
                ctx.fillRect(50 + x * 25, 25 + y * 25, 24, 24);
            });
        }
    }

    function rand(r) {
        return Math.floor(Math.random() * r);
    }

    function processBlockCells(func) {
        for (var i = 0 ; i < block.data.length ; i++) {
            var x = i % block.w;
            var y = Math.floor(i / block.w);
            var v = block.data[i];
            if (0 <= y + block.y && y + block.y < H &&
                0 <= x + block.x && x + block.x < W && v != 0) {
                func(x + block.x, y + block.y, v);
            }
        }
    }

    function init() {
        var canvas = document.getElementById('canvas');
        ctx = canvas.getContext('2d');
        ctx.font = "20pt Arial";

        count = 0;
        score = 0;
        interval = 40; // ゲームスピードをリセット
        keyevents = []; // キーイベントのリセット

        // モーダルウィンドウを非表示にする
        document.getElementById('gameOverModal').style.display = 'none';

        // フィールドの初期化
        field = new Array(H);
        for (var y = 0 ; y < H ; y++) {
            field[y] = new Array(W);
            for (var x = 0 ; x < W ; x++) {
                field[y][x] = (x == 0 || x == W - 1) ? 8 : 0;
            }
        }
        for (var i = 0 ; i < W ; i++) {
            field[H - 1][i] = 8;
        }

        // ブロックの初期化
        goNextBlock();

        // メインループの開始
        if (timer) {
            clearInterval(timer);
        }
        timer = setInterval(mainLoop, 10);
    }

    var bestScore = localStorage.getItem('bestScore') || 0; // ローカルストレージからベストスコアを取得

    function mainLoop() {
    count++;

    // スピードアップ
    if (count % 1000 === 0) {
        interval = Math.max(1, interval - 1);
    }

    // ゲームオーバーの判定
    if (isGameOver()) {
        clearInterval(timer);
        timer = NaN;

        // ベストスコアの更新
        if (score > bestScore) {
            bestScore = score;
            localStorage.setItem('bestScore', bestScore); // 新しいベストスコアを保存
        }

        // モーダルウィンドウを表示
        document.getElementById('gameOverModal').style.display = 'block';
    } else {
        // ブロックの位置を更新
        block.update();
    }

    draw();
}


    function isGameOver() {
        var filled = 0;
        field[0].forEach(function (c) {
            if (c != 0) { filled++ }
        });
        return filled > 2;
    }

    function goNextBlock() {
        block = nextBlock || new Block();
        nextBlock = new Block();
    }

    function isHit(x, y, r) {
        var data = block.type[r];
        for (var i = 0 ; i < block.w ; i++) {
            for (var j = 0 ; j < block.w ; j++) {
                if (i + y >= 0 && j + x >= 0 && i + y < H && j + x < W &&
                    field[i + y][j + x] != 0 && data[i * block.w + j] != 0) {
                    return true;
                }
            }
        }
        return false;
    }

    function eraseLine() {
    var erased = 0;
    for (var y = 20; y >= 0; y--) {   // 下から上へ
        if (field[y].every(function (v) { return v != 0; })) {
            erased++;
            field.splice(y, 1);             // 1行削除
            // 新しい空行を正しく追加
            var newLine = new Array(W).fill(0);
            newLine[0] = 8; // 左壁
            newLine[W - 1] = 8; // 右壁
            field.unshift(newLine);    // 1行追加
            y++;    // 消去した行からもう一度チェック
        }
    }
    return erased;
}

    function draw() {
    // 背景の塗りつぶし
    ctx.fillStyle = 'rgb(0,0,0)';
    ctx.fillRect(0, 0, 700, 600);

    // フィールドの描画
    for (var y = 0; y < H; y++) {
        for (var x = 0; x < W; x++) {
            var v = field[y][x];
            ctx.fillStyle = colors[v];
            ctx.fillRect(50 + x * 25, 25 + y * 25, 24, 24);
        }
    }

    // 落下中のブロックの描画
    if (block) {
        block.draw(ctx);
    }

    // 次に出現するブロックの描画
    if (nextBlock) {
        nextBlock.data.forEach(function (v, i, data) {
            var w = Math.sqrt(data.length);
            var x = i % w;
            var y = Math.floor(i / w);
            ctx.fillStyle = colors[v];
            ctx.fillRect(400 + x * 25, 300 + y * 25, 24, 24);
        });
    }

    // 各種情報の描画
    ctx.fillStyle = 'rgb(0,255,0)';
    ctx.fillText('score', 400, 110);
    ctx.fillText(('0000000' + score).slice(-7), 400, 150);
    ctx.fillText('best score', 400, 190);  // ベストスコアのラベル
    ctx.fillText(('0000000' + bestScore).slice(-7), 400, 230);  // ベストスコアを表示
    ctx.fillText('next:', 400, 270);

    // 外枠のスタイル設定
    ctx.strokeStyle = 'white'; // 枠線の色
    ctx.lineWidth = 1;         // 枠線の太さ

    // SCORE の外枠を描画
    ctx.strokeRect(390, 85, 160, 150); // x, y, 幅, 高さ

    // NEXT の外枠を描画
    ctx.strokeRect(390, 250, 160, 160); // x, y, 幅, 高さ

    if (isNaN(timer)) {
        ctx.fillText('GAME OVER', 380, 70);
    }



    
}

    // リトライボタンの処理
    function retryGame() {
        init();
    }

    // ゲーム一覧に戻るボタンの処理
    function returnToIndex() {
        window.location.href = '../index.html';
    }
    // 画面サイズに合わせてキャンバスをスケーリングする関数
    function adjustCanvasScale() {
        var canvas = document.getElementById('canvas');
        var scale = window.innerHeight / canvas.height;
        canvas.style.transform = 'scale(' + scale + ')';
        canvas.style.transformOrigin = 'top left';
        // キャンバスの親要素のサイズを調整してスクロールバーを防ぐ
        canvas.parentElement.style.width = canvas.width * scale + 'px';
        canvas.parentElement.style.height = canvas.height * scale + 'px';
    }
    // キーイベントのリスナーを一度だけ登録
    window.addEventListener('keydown', function (e) {
        keyevents.push(e.keyCode);
    });

    // ページ読み込み時にキャンバスを調整し、ゲームを開始する
    window.addEventListener('load', function() {
        adjustCanvasScale();
        init(); // ゲーム開始
    });

    // ウィンドウサイズ変更時にキャンバスを再調整する
    window.addEventListener('resize', function() {
        adjustCanvasScale();
    });
    </script>
</head>

<body>
    <div style="position: relative;">
        <canvas id="canvas" width="600" height="600"></canvas>
        <!-- モーダルウィンドウ -->
        <div id="gameOverModal" class="modal" style="display: none;">
            <div class="modal-content">
                <h2>ゲームオーバー</h2>
                <button id="retryButton" onclick="retryGame()">リトライ</button>
                <button id="returnButton" onclick="returnToIndex()">ゲーム一覧に戻る</button>
            </div>
        </div>
    </div>
</body>
</html>
